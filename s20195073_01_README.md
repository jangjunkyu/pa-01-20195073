#ec2202_2020Spring

## File list
s20195073_01_README.md
s20195073_01.cpp
s20195073_01.out

## Command Line Arguments
./s20195073_01.out inputfile.txt outputfile.txt

## Description of your codes
본 코드는 입력받은 문자를 배열하여 만들 수 있는 모든 문자열을 중복 없이 출력하는 코드이다.

main함수에서 가장 먼저 inputfile.txt와 outputfile.txt가 정상적으로 입력되었는지 확인하고,
inputfile에 한줄에 하나씩 입력된 문자를 str 문자열에 저장한다. 그 후 makestr(0)을 호출한다.

makestr 함수는 startnum을 parameter로 가지고 있는 재귀함수이다. 0 위치부터 시작하여
startnum 위치에 대해 사용 가능한 문자를 넣고, makestr(startnum+1)을 호출함으로써 dfs의 형태로
모든 문자열을 구한다. 문자의 사용여부를 확인하기 위해 chkstr 배열에 각 문자의 사용여부를 갱신하며,
최종적으로 완전한 문자열이 생성되면, 이전까지 생성된 다른 문자열들과 비교하여 중복되었는지 확인한다.
중복되지 않았으면, map에<key, value> = <문자열, 1> 꼴로 넣어 위 문자열이 출력되었음을 표시해준다.
map은 단순히 문자열을 비교하는 것(((n!)^2)/2)보다 훨씬 빠른 시간복잡도(logn)를 가지고 있어 이를 활용하였다.

본 코드는 중복을 제거하여 unique한 결과들만을 출력할 수 있다는 장점이 있지만,
이러한 처리를 위해 중복을 하지 않을 때와 비교해 많이 무거워졌다는 단점이 있다.
실제로 10개의 문자를 입력했을 때, 약 45초정도가 소요된다.

##  Algorithmic Analysis
O(n) = n!*logn
전체 n개의 문자가 주어졌을 때, n개의 문자를 배열하는 경우의 수는 최대 n!이다.
본 함수에서 사용된 재귀함수는 n^n의 시간복잡도와 유사하지만, 실제 코드가 작용되는 경우는 문자가 올바르게
배열된 경우이기 때문에, 거시적으로 보았을 때 n!에 더 가깝다는 것을 알 수 있다.
또한, 완전한 문자열이 생성될 때마다 현재까지 생성된 다른 문자열들과 비교하여 중복이 없도록 해야 한다.
본 코드에서는 완전한 문자열이 생성되었을 때, 이를 map에 넣어 중복을 비교하였고, 이때 검색을 위해 사용한
map.find()함수는 약 logn의 시간복잡도를 가지고 있다.
즉, 전체 시간복잡도는 약 n!*logn이 된다.

